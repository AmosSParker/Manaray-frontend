import { HttpErrorResponse } from '@angular/common/http';
import { Inject, Injectable } from '@angular/core';
import * as Sentry from '@sentry/browser';
import { isString } from '@sentry/utils';
import { runOutsideAngular } from './zone';
import * as i0 from "@angular/core";
// https://github.com/angular/angular/blob/master/packages/core/src/util/errors.ts
function tryToUnwrapZonejsError(error) {
    // TODO: once Angular14 is the minimum requirement ERROR_ORIGINAL_ERROR and
    //  getOriginalError from error.ts can be used directly.
    return error && error.ngOriginalError
        ? error.ngOriginalError
        : error;
}
function extractHttpModuleError(error) {
    // The `error` property of http exception can be either an `Error` object, which we can use directly...
    if (isErrorOrErrorLikeObject(error.error)) {
        return error.error;
    }
    // ... or an`ErrorEvent`, which can provide us with the message but no stack...
    if (error.error instanceof ErrorEvent && error.error.message) {
        return error.error.message;
    }
    // ...or the request body itself, which we can use as a message instead.
    if (typeof error.error === 'string') {
        return `Server returned code ${error.status} with body "${error.error}"`;
    }
    // If we don't have any detailed information, fallback to the request message itself.
    return error.message;
}
function isErrorOrErrorLikeObject(value) {
    if (value instanceof Error) {
        return true;
    }
    if (value === null || typeof value !== 'object') {
        return false;
    }
    const candidate = value;
    return (isString(candidate.name) &&
        isString(candidate.message) &&
        (undefined === candidate.stack || isString(candidate.stack)));
}
/**
 * Implementation of Angular's ErrorHandler provider that can be used as a drop-in replacement for the stock one.
 */
class SentryErrorHandler {
    constructor(options) {
        this._registeredAfterSendEventHandler = false;
        this._options = {
            logErrors: true,
            ...options,
        };
    }
    /**
     * Method called for every value captured through the ErrorHandler
     */
    handleError(error) {
        const extractedError = this._extractError(error) || 'Handled unknown error';
        // Capture handled exception and send it to Sentry.
        const eventId = runOutsideAngular(() => Sentry.captureException(extractedError, {
            mechanism: { type: 'angular', handled: false },
        }));
        // When in development mode, log the error to console for immediate feedback.
        if (this._options.logErrors) {
            // eslint-disable-next-line no-console
            console.error(extractedError);
        }
        // Optionally show user dialog to provide details on what happened.
        if (this._options.showDialog) {
            const client = Sentry.getClient();
            if (client && !this._registeredAfterSendEventHandler) {
                client.on('afterSendEvent', (event) => {
                    if (!event.type && event.event_id) {
                        runOutsideAngular(() => {
                            Sentry.showReportDialog({ ...this._options.dialogOptions, eventId: event.event_id });
                        });
                    }
                });
                // We only want to register this hook once in the lifetime of the error handler
                this._registeredAfterSendEventHandler = true;
            }
            else if (!client) {
                runOutsideAngular(() => {
                    Sentry.showReportDialog({ ...this._options.dialogOptions, eventId });
                });
            }
        }
    }
    /**
     * Used to pull a desired value that will be used to capture an event out of the raw value captured by ErrorHandler.
     */
    _extractError(error) {
        // Allow custom overrides of extracting function
        if (this._options.extractor) {
            const defaultExtractor = this._defaultExtractor.bind(this);
            return this._options.extractor(error, defaultExtractor);
        }
        return this._defaultExtractor(error);
    }
    /**
     * Default implementation of error extraction that handles default error wrapping, HTTP responses, ErrorEvent and few other known cases.
     */
    _defaultExtractor(errorCandidate) {
        const error = tryToUnwrapZonejsError(errorCandidate);
        // If it's http module error, extract as much information from it as we can.
        if (error instanceof HttpErrorResponse) {
            return extractHttpModuleError(error);
        }
        // We can handle messages and Error objects directly.
        if (typeof error === 'string' || isErrorOrErrorLikeObject(error)) {
            return error;
        }
        // Nothing was extracted, fallback to default error message.
        return null;
    }
}
SentryErrorHandler.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SentryErrorHandler, deps: [{ token: 'errorHandlerOptions' }], target: i0.ɵɵFactoryTarget.Injectable });
SentryErrorHandler.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SentryErrorHandler, providedIn: 'root' });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "14.3.0", ngImport: i0, type: SentryErrorHandler, decorators: [{
            type: Injectable,
            args: [{ providedIn: 'root' }]
        }], ctorParameters: function () { return [{ type: undefined, decorators: [{
                    type: Inject,
                    args: ['errorHandlerOptions']
                }] }]; } });
/**
 * Factory function that creates an instance of a preconfigured ErrorHandler provider.
 */
function createErrorHandler(config) {
    return new SentryErrorHandler(config);
}
export { createErrorHandler, SentryErrorHandler };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZXJyb3JoYW5kbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vc3JjL2Vycm9yaGFuZGxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQSxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxzQkFBc0IsQ0FBQztBQUV6RCxPQUFPLEVBQUUsTUFBTSxFQUFFLFVBQVUsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUNuRCxPQUFPLEtBQUssTUFBTSxNQUFNLGlCQUFpQixDQUFDO0FBRzFDLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFekMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLE1BQU0sUUFBUSxDQUFDOztBQWlCM0Msa0ZBQWtGO0FBQ2xGLFNBQVMsc0JBQXNCLENBQUMsS0FBYztJQUM1QywyRUFBMkU7SUFDM0Usd0RBQXdEO0lBQ3hELE9BQU8sS0FBSyxJQUFLLEtBQW9DLENBQUMsZUFBZTtRQUNuRSxDQUFDLENBQUUsS0FBb0MsQ0FBQyxlQUFlO1FBQ3ZELENBQUMsQ0FBQyxLQUFLLENBQUM7QUFDWixDQUFDO0FBRUQsU0FBUyxzQkFBc0IsQ0FBQyxLQUF3QjtJQUN0RCx1R0FBdUc7SUFDdkcsSUFBSSx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsS0FBSyxDQUFDLEVBQUU7UUFDekMsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDO0tBQ3BCO0lBRUQsK0VBQStFO0lBQy9FLElBQUksS0FBSyxDQUFDLEtBQUssWUFBWSxVQUFVLElBQUksS0FBSyxDQUFDLEtBQUssQ0FBQyxPQUFPLEVBQUU7UUFDNUQsT0FBTyxLQUFLLENBQUMsS0FBSyxDQUFDLE9BQU8sQ0FBQztLQUM1QjtJQUVELHdFQUF3RTtJQUN4RSxJQUFJLE9BQU8sS0FBSyxDQUFDLEtBQUssS0FBSyxRQUFRLEVBQUU7UUFDbkMsT0FBTyx3QkFBd0IsS0FBSyxDQUFDLE1BQU0sZUFBZSxLQUFLLENBQUMsS0FBSyxHQUFHLENBQUM7S0FDMUU7SUFFRCxxRkFB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SSxDQUFDLElBQUksQ0FBQyxDQUFDO1lBQzNELE9BQU8sSUFBSSxDQUFDLFFBQVEsQ0FBQyxTQUFTLENBQUMsS0FBSyxFQUFFLGdCQUFnQixDQUFDLENBQUM7U0FDekQ7UUFFRCxPQUFPLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxLQUFLLENBQUMsQ0FBQztJQUN2QyxDQUFDO0lBRUQ7O09BRUc7SUFDTyxpQkFBaUIsQ0FBQyxjQUF1QjtRQUNqRCxNQUFNLEtBQUssR0FBRyxzQkFBc0IsQ0FBQyxjQUFjLENBQUMsQ0FBQztRQUVyRCw0RUFBNEU7UUFDNUUsSUFBSSxLQUFLLFlBQVksaUJBQWlCLEVBQUU7WUFDdEMsT0FBTyxzQkFBc0IsQ0FBQyxLQUFLLENBQUMsQ0FBQztTQUN0QztRQUVELHFEQUFxRDtRQUNyRCxJQUFJLE9BQU8sS0FBSyxLQUFLLFFBQVEsSUFBSSx3QkFBd0IsQ0FBQyxLQUFLLENBQUMsRUFBRTtZQUNoRSxPQUFPLEtBQUssQ0FBQztTQUNkO1FBRUQsNERBQTREO1FBQzVELE9BQU8sSUFBSSxDQUFDO0lBQ2QsQ0FBQzs7K0dBeEZHLGtCQUFrQixrQkFNSyxxQkFBcUI7bUhBTjVDLGtCQUFrQixjQURFLE1BQU07MkZBQzFCLGtCQUFrQjtrQkFEdkIsVUFBVTttQkFBQyxFQUFFLFVBQVUsRUFBRSxNQUFNLEVBQUU7OzBCQU9aLE1BQU07MkJBQUMscUJBQXFCOztBQXFGbEQ7O0dBRUc7QUFDSCxTQUFTLGtCQUFrQixDQUFDLE1BQTRCO0lBQ3RELE9BQU8sSUFBSSxrQkFBa0IsQ0FBQyxNQUFNLENBQUMsQ0FBQztBQUN4QyxDQUFDO0FBRUQsT0FBTyxFQUFFLGtCQUFrQixFQUFFLGtCQUFrQixFQUFFLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBIdHRwRXJyb3JSZXNwb25zZSB9IGZyb20gJ0Bhbmd1bGFyL2NvbW1vbi9odHRwJztcbmltcG9ydCB0eXBlIHsgRXJyb3JIYW5kbGVyIGFzIEFuZ3VsYXJFcnJvckhhbmRsZXIgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCB7IEluamVjdCwgSW5qZWN0YWJsZSB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0ICogYXMgU2VudHJ5IGZyb20gJ0BzZW50cnkvYnJvd3Nlcic7XG5pbXBvcnQgdHlwZSB7IFJlcG9ydERpYWxvZ09wdGlvbnMgfSBmcm9tICdAc2VudHJ5L2Jyb3dzZXInO1xuaW1wb3J0IHR5cGUgeyBFdmVudCB9IGZyb20gJ0BzZW50cnkvdHlwZXMnO1xuaW1wb3J0IHsgaXNTdHJpbmcgfSBmcm9tICdAc2VudHJ5L3V0aWxzJztcblxuaW1wb3J0IHsgcnVuT3V0c2lkZUFuZ3VsYXIgfSBmcm9tICcuL3pvbmUnO1xuXG4vKipcbiAqIE9wdGlvbnMgdXNlZCB0byBjb25maWd1cmUgdGhlIGJlaGF2aW9yIG9mIHRoZSBBbmd1bGFyIEVycm9ySGFuZGxlci5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBFcnJvckhhbmRsZXJPcHRpb25zIHtcbiAgbG9nRXJyb3JzPzogYm9vbGVhbjtcbiAgc2hvd0RpYWxvZz86IGJvb2xlYW47XG4gIGRpYWxvZ09wdGlvbnM/OiBSZXBvcnREaWFsb2dPcHRpb25zO1xuICAvKipcbiAgICogQ3VzdG9tIGltcGxlbWVudGF0aW9uIG9mIGVycm9yIGV4dHJhY3Rpb24gZnJvbSB0aGUgcmF3IHZhbHVlIGNhcHR1cmVkIGJ5IHRoZSBBbmd1bGFyLlxuICAgKiBAcGFyYW0gZXJyb3IgVmFsdWUgY2FwdHVyZWQgYnkgQW5ndWxhcidzIEVycm9ySGFuZGxlciBwcm92aWRlclxuICAgKiBAcGFyYW0gZGVmYXVsdEV4dHJhY3RvciBEZWZhdWx0IGltcGxlbWVudGF0aW9uIHRoYXQgY2FuIGJlIHVzZWQgYXMgdGhlIGZhbGxiYWNrIGluIGNhc2Ugb2YgY3VzdG9tIGltcGxlbWVudGF0aW9uXG4gICAqL1xuICBleHRyYWN0b3I/KGVycm9yOiB1bmtub3duLCBkZWZhdWx0RXh0cmFjdG9yOiAoZXJyb3I6IHVua25vd24pID0+IHVua25vd24pOiB1bmtub3duO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyL2Jsb2IvbWFzdGVyL3BhY2thZ2VzL2NvcmUvc3JjL3V0aWwvZXJyb3JzLnRzXG5mdW5jdGlvbiB0cnlUb1Vud3JhcFpvbmVqc0Vycm9yKGVycm9yOiB1bmtub3duKTogdW5rbm93biB8IEVycm9yIHtcbiAgLy8gVE9ETzogb25jZSBBbmd1bGFyMTQgaXMgdGhlIG1pbmltdW0gcmVxdWlyZW1lbnQgRVJST1JfT1JJR0lOQUxfRVJST1IgYW5kXG4gIC8vICBnZXRPcmlnaW5hbEVycm9yIGZyb20gZXJyb3IudHMgY2FuIGJlIHVzZWQgZGlyZWN0bHkuXG4gIHJldHVybiBlcnJvciAmJiAoZXJyb3IgYXMgeyBuZ09yaWdpbmFsRXJyb3I6IEVycm9yIH0pLm5nT3JpZ2luYWxFcnJvclxuICAgID8gKGVycm9yIGFzIHsgbmdPcmlnaW5hbEVycm9yOiBFcnJvciB9KS5uZ09yaWdpbmFsRXJyb3JcbiAgICA6IGVycm9yO1xufVxuXG5mdW5jdGlvbiBleHRyYWN0SHR0cE1vZHVsZUVycm9yKGVycm9yOiBIdHRwRXJyb3JSZXNwb25zZSk6IHN0cmluZyB8IEVycm9yIHtcbiAgLy8gVGhlIGBlcnJvcmAgcHJvcGVydHkgb2YgaHR0cCBleGNlcHRpb24gY2FuIGJlIGVpdGhlciBhbiBgRXJyb3JgIG9iamVjdCwgd2hpY2ggd2UgY2FuIHVzZSBkaXJlY3RseS4uLlxuICBpZiAoaXNFcnJvck9yRXJyb3JMaWtlT2JqZWN0KGVycm9yLmVycm9yKSkge1xuICAgIHJldHVybiBlcnJvci5lcnJvcjtcbiAgfVxuXG4gIC8vIC4uLiBvciBhbmBFcnJvckV2ZW50YCwgd2hpY2ggY2FuIHByb3ZpZGUgdXMgd2l0aCB0aGUgbWVzc2FnZSBidXQgbm8gc3RhY2suLi5cbiAgaWYgKGVycm9yLmVycm9yIGluc3RhbmNlb2YgRXJyb3JFdmVudCAmJiBlcnJvci5lcnJvci5tZXNzYWdlKSB7XG4gICAgcmV0dXJuIGVycm9yLmVycm9yLm1lc3NhZ2U7XG4gIH1cblxuICAvLyAuLi5vciB0aGUgcmVxdWVzdCBib2R5IGl0c2VsZiwgd2hpY2ggd2UgY2FuIHVzZSBhcyBhIG1lc3NhZ2UgaW5zdGVhZC5cbiAgaWYgKHR5cGVvZiBlcnJvci5lcnJvciA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYFNlcnZlciByZXR1cm5lZCBjb2RlICR7ZXJyb3Iuc3RhdHVzfSB3aXRoIGJvZHkgXCIke2Vycm9yLmVycm9yfVwiYDtcbiAgfVxuXG4gIC8vIElmIHdlIGRvbid0IGhhdmUgYW55IGRldGFpbGVkIGluZm9ybWF0aW9uLCBmYWxsYmFjayB0byB0aGUgcmVxdWVzdCBtZXNzYWdlIGl0c2VsZi5cbiAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG59XG5cbnR5cGUgRXJyb3JDYW5kaWRhdGUgPSB7XG4gIG5hbWU/OiB1bmtub3duO1xuICBtZXNzYWdlPzogdW5rbm93bjtcbiAgc3RhY2s/OiB1bmtub3duO1xufTtcblxuZnVuY3Rpb24gaXNFcnJvck9yRXJyb3JMaWtlT2JqZWN0KHZhbHVlOiB1bmtub3duKTogdmFsdWUgaXMgRXJyb3Ige1xuICBpZiAodmFsdWUgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBjb25zdCBjYW5kaWRhdGUgPSB2YWx1ZSBhcyBFcnJvckNhbmRpZGF0ZTtcblxuICByZXR1cm4gKFxuICAgIGlzU3RyaW5nKGNhbmRpZGF0ZS5uYW1lKSAmJlxuICAgIGlzU3RyaW5nKGNhbmRpZGF0ZS5tZXNzYWdlKSAmJlxuICAgICh1bmRlZmluZWQgPT09IGNhbmRpZGF0ZS5zdGFjayB8fCBpc1N0cmluZyhjYW5kaWRhdGUuc3RhY2spKVxuICApO1xufVxuXG4vKipcbiAqIEltcGxlbWVudGF0aW9uIG9mIEFuZ3VsYXIncyBFcnJvckhhbmRsZXIgcHJvdmlkZXIgdGhhdCBjYW4gYmUgdXNlZCBhcyBhIGRyb3AtaW4gcmVwbGFjZW1lbnQgZm9yIHRoZSBzdG9jayBvbmUuXG4gKi9cbkBJbmplY3RhYmxlKHsgcHJvdmlkZWRJbjogJ3Jvb3QnIH0pXG5jbGFzcyBTZW50cnlFcnJvckhhbmRsZXIgaW1wbGVtZW50cyBBbmd1bGFyRXJyb3JIYW5kbGVyIHtcbiAgcHJvdGVjdGVkIHJlYWRvbmx5IF9vcHRpb25zOiBFcnJvckhhbmRsZXJPcHRpb25zO1xuXG4gIC8qIGluZGljYXRlcyBpZiB3ZSBhbHJlYWR5IHJlZ2lzdGVyZWQgb3VyIHRoZSBhZnRlclNlbmRFdmVudCBoYW5kbGVyICovXG4gIHByaXZhdGUgX3JlZ2lzdGVyZWRBZnRlclNlbmRFdmVudEhhbmRsZXI7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKEBJbmplY3QoJ2Vycm9ySGFuZGxlck9wdGlvbnMnKSBvcHRpb25zPzogRXJyb3JIYW5kbGVyT3B0aW9ucykge1xuICAgIHRoaXMuX3JlZ2lzdGVyZWRBZnRlclNlbmRFdmVudEhhbmRsZXIgPSBmYWxzZTtcblxuICAgIHRoaXMuX29wdGlvbnMgPSB7XG4gICAgICBsb2dFcnJvcnM6IHRydWUsXG4gICAgICAuLi5vcHRpb25zLFxuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIGNhbGxlZCBmb3IgZXZlcnkgdmFsdWUgY2FwdHVyZWQgdGhyb3VnaCB0aGUgRXJyb3JIYW5kbGVyXG4gICAqL1xuICBwdWJsaWMgaGFuZGxlRXJyb3IoZXJyb3I6IHVua25vd24pOiB2b2lkIHtcbiAgICBjb25zdCBleHRyYWN0ZWRFcnJvciA9IHRoaXMuX2V4dHJhY3RFcnJvcihlcnJvcikgfHwgJ0hhbmRsZWQgdW5rbm93biBlcnJvcic7XG5cbiAgICAvLyBDYXB0dXJlIGhhbmRsZWQgZXhjZXB0aW9uIGFuZCBzZW5kIGl0IHRvIFNlbnRyeS5cbiAgICBjb25zdCBldmVudElkID0gcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT5cbiAgICAgIFNlbnRyeS5jYXB0dXJlRXhjZXB0aW9uKGV4dHJhY3RlZEVycm9yLCB7XG4gICAgICAgIG1lY2hhbmlzbTogeyB0eXBlOiAnYW5ndWxhcicsIGhhbmRsZWQ6IGZhbHNlIH0sXG4gICAgICB9KSxcbiAgICApO1xuXG4gICAgLy8gV2hlbiBpbiBkZXZlbG9wbWVudCBtb2RlLCBsb2cgdGhlIGVycm9yIHRvIGNvbnNvbGUgZm9yIGltbWVkaWF0ZSBmZWVkYmFjay5cbiAgICBpZiAodGhpcy5fb3B0aW9ucy5sb2dFcnJvcnMpIHtcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXG4gICAgICBjb25zb2xlLmVycm9yKGV4dHJhY3RlZEVycm9yKTtcbiAgICB9XG5cbiAgICAvLyBPcHRpb25hbGx5IHNob3cgdXNlciBkaWFsb2cgdG8gcHJvdmlkZSBkZXRhaWxzIG9uIHdoYXQgaGFwcGVuZWQuXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuc2hvd0RpYWxvZykge1xuICAgICAgY29uc3QgY2xpZW50ID0gU2VudHJ5LmdldENsaWVudCgpO1xuXG4gICAgICBpZiAoY2xpZW50ICYmICF0aGlzLl9yZWdpc3RlcmVkQWZ0ZXJTZW5kRXZlbnRIYW5kbGVyKSB7XG4gICAgICAgIGNsaWVudC5vbignYWZ0ZXJTZW5kRXZlbnQnLCAoZXZlbnQ6IEV2ZW50KSA9PiB7XG4gICAgICAgICAgaWYgKCFldmVudC50eXBlICYmIGV2ZW50LmV2ZW50X2lkKSB7XG4gICAgICAgICAgICBydW5PdXRzaWRlQW5ndWxhcigoKSA9PiB7XG4gICAgICAgICAgICAgIFNlbnRyeS5zaG93UmVwb3J0RGlhbG9nKHsgLi4udGhpcy5fb3B0aW9ucy5kaWFsb2dPcHRpb25zLCBldmVudElkOiBldmVudC5ldmVudF9pZCEgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFdlIG9ubHkgd2FudCB0byByZWdpc3RlciB0aGlzIGhvb2sgb25jZSBpbiB0aGUgbGlmZXRpbWUgb2YgdGhlIGVycm9yIGhhbmRsZXJcbiAgICAgICAgdGhpcy5fcmVnaXN0ZXJlZEFmdGVyU2VuZEV2ZW50SGFuZGxlciA9IHRydWU7XG4gICAgICB9IGVsc2UgaWYgKCFjbGllbnQpIHtcbiAgICAgICAgcnVuT3V0c2lkZUFuZ3VsYXIoKCkgPT4ge1xuICAgICAgICAgIFNlbnRyeS5zaG93UmVwb3J0RGlhbG9nKHsgLi4udGhpcy5fb3B0aW9ucy5kaWFsb2dPcHRpb25zLCBldmVudElkIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBwdWxsIGEgZGVzaXJlZCB2YWx1ZSB0aGF0IHdpbGwgYmUgdXNlZCB0byBjYXB0dXJlIGFuIGV2ZW50IG91dCBvZiB0aGUgcmF3IHZhbHVlIGNhcHR1cmVkIGJ5IEVycm9ySGFuZGxlci5cbiAgICovXG4gIHByb3RlY3RlZCBfZXh0cmFjdEVycm9yKGVycm9yOiB1bmtub3duKTogdW5rbm93biB7XG4gICAgLy8gQWxsb3cgY3VzdG9tIG92ZXJyaWRlcyBvZiBleHRyYWN0aW5nIGZ1bmN0aW9uXG4gICAgaWYgKHRoaXMuX29wdGlvbnMuZXh0cmFjdG9yKSB7XG4gICAgICBjb25zdCBkZWZhdWx0RXh0cmFjdG9yID0gdGhpcy5fZGVmYXVsdEV4dHJhY3Rvci5iaW5kKHRoaXMpO1xuICAgICAgcmV0dXJuIHRoaXMuX29wdGlvbnMuZXh0cmFjdG9yKGVycm9yLCBkZWZhdWx0RXh0cmFjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcy5fZGVmYXVsdEV4dHJhY3RvcihlcnJvcik7XG4gIH1cblxuICAvKipcbiAgICogRGVmYXVsdCBpbXBsZW1lbnRhdGlvbiBvZiBlcnJvciBleHRyYWN0aW9uIHRoYXQgaGFuZGxlcyBkZWZhdWx0IGVycm9yIHdyYXBwaW5nLCBIVFRQIHJlc3BvbnNlcywgRXJyb3JFdmVudCBhbmQgZmV3IG90aGVyIGtub3duIGNhc2VzLlxuICAgKi9cbiAgcHJvdGVjdGVkIF9kZWZhdWx0RXh0cmFjdG9yKGVycm9yQ2FuZGlkYXRlOiB1bmtub3duKTogdW5rbm93biB7XG4gICAgY29uc3QgZXJyb3IgPSB0cnlUb1Vud3JhcFpvbmVqc0Vycm9yKGVycm9yQ2FuZGlkYXRlKTtcblxuICAgIC8vIElmIGl0J3MgaHR0cCBtb2R1bGUgZXJyb3IsIGV4dHJhY3QgYXMgbXVjaCBpbmZvcm1hdGlvbiBmcm9tIGl0IGFzIHdlIGNhbi5cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBIdHRwRXJyb3JSZXNwb25zZSkge1xuICAgICAgcmV0dXJuIGV4dHJhY3RIdHRwTW9kdWxlRXJyb3IoZXJyb3IpO1xuICAgIH1cblxuICAgIC8vIFdlIGNhbiBoYW5kbGUgbWVzc2FnZXMgYW5kIEVycm9yIG9iamVjdHMgZGlyZWN0bHkuXG4gICAgaWYgKHR5cGVvZiBlcnJvciA9PT0gJ3N0cmluZycgfHwgaXNFcnJvck9yRXJyb3JMaWtlT2JqZWN0KGVycm9yKSkge1xuICAgICAgcmV0dXJuIGVycm9yO1xuICAgIH1cblxuICAgIC8vIE5vdGhpbmcgd2FzIGV4dHJhY3RlZCwgZmFsbGJhY2sgdG8gZGVmYXVsdCBlcnJvciBtZXNzYWdlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogRmFjdG9yeSBmdW5jdGlvbiB0aGF0IGNyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgYSBwcmVjb25maWd1cmVkIEVycm9ySGFuZGxlciBwcm92aWRlci5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlRXJyb3JIYW5kbGVyKGNvbmZpZz86IEVycm9ySGFuZGxlck9wdGlvbnMpOiBTZW50cnlFcnJvckhhbmRsZXIge1xuICByZXR1cm4gbmV3IFNlbnRyeUVycm9ySGFuZGxlcihjb25maWcpO1xufVxuXG5leHBvcnQgeyBjcmVhdGVFcnJvckhhbmRsZXIsIFNlbnRyeUVycm9ySGFuZGxlciB9O1xuIl19